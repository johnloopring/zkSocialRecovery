import "signatures/verifyEddsa" as verifyEddsa;
from "ecc/babyjubjubParams" import BabyJubJubParams;
import "hashes/sha256/512bitPacked" as sha256packed;
import "hashes/pedersen/512bitBool" as pedersen;
import "ecc/edwardsCompress.zok" as edwardsCompress;
import "utils/casts/bool_256_to_u32_8.zok" as bool_256_to_u32_8;

const BabyJubJubParams BABYJUBJUB_PARAMS = BabyJubJubParams {
    // Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
    JUBJUB_C: 8, // Cofactor
    JUBJUB_A: 168700, // Coefficient A
    JUBJUB_D: 168696, // Coefficient D

    // Montgomery parameters
    MONT_A: 168698,
    MONT_B: 1,

    // Point at infinity
    INFINITY: [0, 1],

    // Generator
    Gu: 16540640123574156134436876038791482806971768689494387082833631921987005038935,
    Gv: 20819045374670962167435360035096875258406992893633759881276124905556507972311
};

def main(private field[2] R, private field S, private field[2] A, u32[8] M0, u32[8] M1, u32[8] H) {
    
    bool isVerified = verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);

    bool[512] mut empty = [false; 512];
    bool[256] compressedA = edwardsCompress(A);
    for u32 i in 0..256 {
        empty[i + 256] = compressedA[i];
    }
    u32[8] h = bool_256_to_u32_8(pedersen(empty));
    
    assert(isVerified && h == H);
    return;
}
