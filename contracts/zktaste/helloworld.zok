import "signatures/verifyEddsa" as verifyEddsa;
from "ecc/babyjubjubParams" import BabyJubJubParams;
import "hashes/sha256/512bitPacked" as sha256packed;
import "hashes/pedersen/512bitBool" as pedersen;
import "ecc/edwardsCompress.zok" as edwardsCompress;
import "utils/casts/bool_256_to_u32_8.zok" as bool_256_to_u32_8;
// hashes/pedersen/512bit.zok

const BabyJubJubParams BABYJUBJUB_PARAMS = BabyJubJubParams {
    // Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
    JUBJUB_C: 8, // Cofactor
    JUBJUB_A: 168700, // Coefficient A
    JUBJUB_D: 168696, // Coefficient D

    // Montgomery parameters
    MONT_A: 168698,
    MONT_B: 1,

    // Point at infinity
    INFINITY: [0, 1],

    // Generator
    Gu: 16540640123574156134436876038791482806971768689494387082833631921987005038935,
    Gv: 20819045374670962167435360035096875258406992893633759881276124905556507972311
};
// def main() {
//     field[2] R = [20197911405516193152560090893341588680064377398162745404177962124159545390767, 9171190326927340493105240100684097896571028312802691203521747450053192554927];
//     field S = 6050429445242986634735172402304257690628456074852538287769363221635064371045;

//     // Public Key
//     field[2] A = [14897476871502190904409029696666322856887678969656209656241038339251270171395, 16668832459046858928951622951481252834155254151733002984053501254009901876174];

//     u32[8] M0 = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000];
//     u32[8] M1 = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000005];

//     // bool isVerified = verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);
//     assert(verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS));

//     return;
// }
// x^3 = 8999999999999999*71
// 2**3 8
// def main() {

//     field[2] R = [10041775272610680597649138558111867140088287599035431170728241228669634925671, 19045584355489137154300255038437027652180257880634202059955435891798466344432];
//     field S = 14517916597883362893064608394843629693674165114908520112595055382047085957383;

//     // Public Key
//     field[2] A = [14897476871502190904409029696666322856887678969656209656241038339251270171395, 16668832459046858928951622951481252834155254151733002984053501254009901876174];

//     u32[8] M0 = [3814687126, 4207057211, 2301474087, 1696421512, 1054042432, 4114589074, 2402006685, 2358319779];
//     u32[8] M1 = [2636307903, 771130895, 3338794104, 910337493, 3941248527, 2566242658, 3403499691, 2178970740];
//     // 11dd22
//     // 3814687126 4207057211 2301474087 1696421512 1054042432 4114589074 2402006685 2358319779 
//     // 2636307903 771130895 3338794104 910337493 3941248527 2566242658 3403499691 2178970740
//     // bool isVerified = verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);
//     assert(verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS));

//     return;
// }

// def main() {
//     field[2] R = [10041775272610680597649138558111867140088287599035431170728241228669634925671, 19045584355489137154300255038437027652180257880634202059955435891798466344432];
//     field S = 14517916597883362893064608394843629693674165114908520112595055382047085957383;

//     // Public Key
//     field[2] A = [14897476871502190904409029696666322856887678969656209656241038339251270171395, 16668832459046858928951622951481252834155254151733002984053501254009901876174];

//     u32[8] M0 = [3814687126, 4207057211, 2301474087, 1696421512, 1054042432, 4114589074, 2402006685, 2358319779];
//     u32[8] M1 = [2636307903, 771130895, 3338794104, 910337493, 3941248527, 2566242658, 3403499691, 2178970740];
//     // 11dd22
//     // 3814687126 4207057211 2301474087 1696421512 1054042432 4114589074 2402006685 2358319779 
//     // 2636307903 771130895 3338794104 910337493 3941248527 2566242658 3403499691 2178970740
//     bool isVerified = verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);
//     // verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);
//     u32[8] h = pedersen([
//         0,
//         0,
//         0,
//         0,
//         0,
//         0,
//         0,
//         0,
//         0xa4da398e,
//         0xd1996eae,
//         0x6dafb3a6,
//         0x87806e3a,
//         0x49c3add6,
//         0x949774d6,
//         0x017b30a6,
//         0x6b2503ce
//     ]);
//     u32[8] hash = [
//         0x149b20e4,
//         0xe69fc048,
//         0xe6e2b29e,
//         0x420a9b61,
//         0xfc7987ba,
//         0x59dba60d,
//         0xebd9837e,
//         0xfdb551b2
//     ];
//     // u32 secondHash = 0x00000000;
//     // h[0] == firstHash;
//     // h[1] == secondHash;
//     assert(isVerified && h == hash);
//     // h = sha256packed([a, b, c, d])


//     return ;
// }

//   private field r_x, private field r_y, private field s, private field pubkey_x, private field pubkey_y, u32[8] m0  
def main(private field[2] R, private field S, private field[2] A, u32[8] M0, u32[8] M1, u32[8] H) {
    
    bool isVerified = verifyEddsa(R, S, A, M0, M1, BABYJUBJUB_PARAMS);

    bool[512] mut empty = [false; 512];
    bool[256] compressedA = edwardsCompress(A);
    for u32 i in 0..256 {
        empty[i + 256] = compressedA[i];
    }
    u32[8] h = bool_256_to_u32_8(pedersen(empty));
    
    assert(isVerified && h == H);
    return;
}
